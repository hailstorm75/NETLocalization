using Localization.Generator.Translation;
using System.Collections.Immutable;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;

namespace Localization.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class TranslationsSourceGenerator : IIncrementalGenerator
{
    #region Constants

    private const string ATTRIBUTE_NAME = "Localization.Shared.Attributes.TranslationProviderAttribute";
    private const string L_STRING_NAME = "Localization.Shared.Models.LString";
    private const string TRANSLATION_SET_NAME = "Localization.Shared.Models.TranslationSet";
    private const string TOOL_NAME = "Localizations.Generator";
    private const string VERSION = "1.0.0";
    private const string TRANSLATIONS_NAMESPACE = "NAMESPACE";

    #endregion

    #region Nested Types

    private record Data(INamedTypeSymbol Symbol, string LocalizationSource);
    private record TranslationFile(string Name, TranslationsCollection Collection);

    #endregion

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var translations = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(".xml"))
            .Select(static (text, _) =>
            {
                var name = Path.GetFileNameWithoutExtension(text.Path);

                if (!text.Path.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
                    return null;

                var data = text.GetText()?.ToString();
                if (data is null)
                    return null;

                return ParserHelper.TryParse(data, out var collection)
                    ? new TranslationFile(name, collection)
                    : null;
            })
            .Where(static file => file is not null)
            .Collect();

        var targetClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: ATTRIBUTE_NAME,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (context, _) =>
                {
                    var symbol = (INamedTypeSymbol)context.TargetSymbol;
                    var attributeData = context.Attributes
                        .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == ATTRIBUTE_NAME);

                    var source = attributeData?.ConstructorArguments.FirstOrDefault().Value?.ToString();
                    return string.IsNullOrEmpty(source)
                        ? null
                        : new Data(symbol, source!);
                }
        )
        .Where(static data => data is not null)
        .Collect();

        var combined = translations.Combine(targetClasses);

        context.RegisterSourceOutput(combined, static (ctx, pipeline) => Execute(ctx, pipeline));
    }

    private static void Execute(SourceProductionContext context, (ImmutableArray<TranslationFile?> translations, ImmutableArray<Data?> dataSet) pipeline)
    {
        var translationFiles = pipeline.translations.ToDictionary(
            static file => file!.Name,
            static file => file!.Collection,
            StringComparer.OrdinalIgnoreCase);

        foreach (var data in pipeline.dataSet)
        {
            if (data is null || !translationFiles.TryGetValue(data.LocalizationSource, out var collection))
                continue;

            var classSource = ProcessData(data, collection);
            if (string.IsNullOrEmpty(classSource))
                continue;

            context.AddSource($"{data.Symbol.Name}.g.cs", classSource);
        }
    }
    
    private static string NormalizeString(string input, bool capitalize = false)
    {
        if (string.IsNullOrEmpty(input))
            return string.Empty;

        Span<char> newString = stackalloc char[input.Length];
        for (var i = 0; i < input.Length; i++)
        {
            // Normalize string to be a valid C# identifier
            var c = input[i];
            if (char.IsLetterOrDigit(c) || c == '_')
            {
                if (i == 0 && char.IsDigit(c))
                    // If the first character is a digit, replace it with an underscore
                    newString[i] = '_';
                else
                    newString[i] = capitalize ? char.ToUpper(c) : c;
            }
            else
                newString[i] = '_'; // Replace invalid characters with underscore
        }

        return newString.ToString();
    }

    private static string ProcessData(Data data, TranslationsCollection translations)
    {
        // Creates a TextWriter to use as the base output writer.
        var baseTextWriter = new StringWriter();
        var indentWriter = new IndentedTextWriter(baseTextWriter, "    ");
        indentWriter.Indent = 0;

        indentWriter.WriteLine("// <auto-generated />");
        indentWriter.WriteLine("#pragma warning disable 1591"); // Disable warnings for missing XML comments
        indentWriter.WriteLineNoTabs(string.Empty);
        indentWriter.WriteLine($"namespace {data.Symbol.ContainingNamespace.ToDisplayString()};");
        indentWriter.WriteLineNoTabs(string.Empty);
        indentWriter.WriteLine($"static partial class {data.Symbol.Name}");
        indentWriter.WriteLine("{");
        indentWriter.Indent++;

        var languages = translations
            .SelectMany(static translations => translations.Items.Values)
            .Select(static translation => translation.Language)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToDictionary(static key => key, static key => NormalizeString(key, true), StringComparer.OrdinalIgnoreCase);

        PrintLanguages(translations, indentWriter, languages);

        indentWriter.WriteLineNoTabs(string.Empty);

        PrintTranslationsProvider(translations, languages, indentWriter);

        indentWriter.WriteLineNoTabs(string.Empty);

        PrintProperties(translations, indentWriter);

        indentWriter.Indent--;
        indentWriter.WriteLine("}");

        return baseTextWriter.ToString();
    }

    private static void PrintLanguages(TranslationsCollection translations, IndentedTextWriter indentWriter, Dictionary<string, string> languages)
    {
        indentWriter.WriteLine("#region Constants");
        indentWriter.WriteLineNoTabs(string.Empty);

        indentWriter.WriteLine($"private const string {TRANSLATIONS_NAMESPACE} = \"{translations.Namespace}\";");

        foreach (var language in languages)
            indentWriter.WriteLine($"private const string {language.Value} = \"{language.Key}\";");

        indentWriter.WriteLineNoTabs(string.Empty);
        indentWriter.WriteLine("#endregion");
    }

    private static void PrintTranslationsProvider(TranslationsCollection translations, Dictionary<string, string> languages, IndentedTextWriter indentWriter)
    {
        indentWriter.WriteLine("/// <summary>Enumerates translated strings</summary>");
        indentWriter.WriteLine("[global::System.Diagnostics.Contracts.Pure]");
        indentWriter.WriteLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
        indentWriter.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCode(\"{TOOL_NAME}\", \"{VERSION}\")]");
        indentWriter.WriteLine($"public static global::System.Collections.Generic.IEnumerable<global::{TRANSLATION_SET_NAME}> GetTranslations()");
        indentWriter.WriteLine("{");
        indentWriter.Indent++;

        foreach (var set in translations)
        {
            indentWriter.WriteLine($"yield return new global::{TRANSLATION_SET_NAME}");
            indentWriter.WriteLine("{");
            indentWriter.Indent++;

            {
                indentWriter.WriteLine($"Source = {set.Key},");

                if (set.Items.Count > 0)
                {
                    indentWriter.WriteLine($"Translations = new global::System.Collections.Generic.Dictionary<string, string>(global::System.StringComparer.OrdinalIgnoreCase)");
                    indentWriter.WriteLine("{");
                    indentWriter.Indent++;

                    foreach (var item in set.Items.Values)
                    {
                        if (languages.TryGetValue(item.Language, out var @field))
                            indentWriter.WriteLine($"[{@field}] = \"{item.Value}\",");
                        else
                            indentWriter.WriteLine($"[\"{item.Language}\"] = \"{item.Value}\",");
                    }

                    indentWriter.Indent--;
                    indentWriter.WriteLine("}");
                }
                else
                    indentWriter.WriteLine("Translations = global::System.Collections.Immutable.ImmutableDictionary<string, string>.Empty");
            }

            indentWriter.Indent--;
            indentWriter.WriteLine("};");
        }
        
        indentWriter.Indent--;
        indentWriter.WriteLine("}");
    }

    private static void PrintProperties(TranslationsCollection translations, IndentedTextWriter indentWriter)
    {
        indentWriter.WriteLine("#region Strings");
        indentWriter.WriteLineNoTabs(string.Empty);
        
        var index = 0;
        foreach (var set in translations)
        {
            indentWriter.WriteLine($"/// <summary>{set.Description}</summary>");

            if (set.Items.TryGetValue("en", out var englishTranslation) && !string.IsNullOrEmpty(englishTranslation.Value))
                indentWriter.WriteLine($"/// <remarks>{englishTranslation.Value}</remarks>");

            indentWriter.WriteLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
            indentWriter.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCode(\"{TOOL_NAME}\", \"{VERSION}\")]");
            indentWriter.WriteLine($"public static global::{L_STRING_NAME} {set.Key} {{ get; }} = new global::{L_STRING_NAME}");
            indentWriter.WriteLine("{");
            indentWriter.Indent++;

            {
                indentWriter.WriteLine($"Namespace = {TRANSLATIONS_NAMESPACE},");
                indentWriter.WriteLine($"Key = \"{set.Key}\"");
            }

            indentWriter.Indent--;
            indentWriter.WriteLine("};");

            if (index < translations.Count - 1)
                indentWriter.WriteLineNoTabs(string.Empty);

            index++;
        }

        indentWriter.WriteLineNoTabs(string.Empty);
        indentWriter.WriteLine("#endregion");
    }
}
