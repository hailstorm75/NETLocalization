using Localization.Generator.Translation;
using Localization.Shared.Attributes;
using Localization.Shared.Models;
using System.Collections.Immutable;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis;

namespace Localization.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class TranslationsSourceGenerator : IIncrementalGenerator
{
    #region Constants

    private const string TOOL_NAME = "Localizations.Generator";
    private const string VERSION = "1.0.0";

    #endregion

    #region Nested Types

    private record Data(INamedTypeSymbol Symbol, string LocalizationSource);
    private record TranslationFile(string Name, TranslationsCollection Collection);

    #endregion

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var translations = context.AdditionalTextsProvider
            .Where(static text => text.Path.EndsWith(".xml"))
            .Select(static (text, _) =>
            {
                var name = Path.GetFileNameWithoutExtension(text.Path);

                return ParserHelper.TryParse(text.Path, out var collection)
                    ? new TranslationFile(name, collection)
                    : null;
            })
            .Where(static file => file is not null)
            .Collect();

        var targetClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: typeof(TranslationProviderAttribute).FullName!,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (context, _) =>
                {
                    var symbol = (INamedTypeSymbol)context.TargetSymbol;
                    var attributeData = context.Attributes
                        .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == typeof(TranslationProviderAttribute).FullName);

                    var source = attributeData?.ConstructorArguments.FirstOrDefault().Value?.ToString();
                    return string.IsNullOrEmpty(source)
                        ? null
                        : new Data(symbol, source!);
                }
        )
        .Where(static data => data is not null)
        .Collect();

        IncrementalValueProvider<(ImmutableArray<TranslationFile?>, ImmutableArray<Data?>)> combined = translations.Combine(targetClasses);

        context.RegisterSourceOutput(combined, Execute);
    }

    private static void Execute(SourceProductionContext context, (ImmutableArray<TranslationFile?> translations, ImmutableArray<Data?> dataSet) pipeline)
    {
        var translationFiles = pipeline.translations.ToDictionary(
            static file => file!.Name,
            static file => file!.Collection,
            StringComparer.OrdinalIgnoreCase);

        foreach (var data in pipeline.dataSet)
        {
            if (data is null || !translationFiles.TryGetValue(data.LocalizationSource, out var collection))
                continue;

            var classSource = ProcessData(data, collection);
            if (string.IsNullOrEmpty(classSource))
                continue;

            context.AddSource($"{data.Symbol.Name}.g.cs", classSource);
        }
    }

    private static string ProcessData(Data data, TranslationsCollection translations)
    {
        // Creates a TextWriter to use as the base output writer.
        var baseTextWriter = new StringWriter();
        var indentWriter = new IndentedTextWriter(baseTextWriter, "    ");
        indentWriter.Indent = 0;

        indentWriter.WriteLine("// <auto-generated />");
        indentWriter.WriteLine("#pragma warning disable 1591"); // Disable warnings for missing XML comments
        indentWriter.WriteLine();
        indentWriter.WriteLine($"namespace {data.Symbol.ContainingNamespace.ToDisplayString()};");
        indentWriter.WriteLine();
        indentWriter.WriteLine($"partial class {data.Symbol.Name}");
        indentWriter.WriteLine("{");
        indentWriter.Indent++;

        foreach (var set in translations)
        {
            indentWriter.WriteLine($"/// <summary>{set.Description}</summary>");

            if (set.Items.TryGetValue("en", out var englishTranslation) && !string.IsNullOrEmpty(englishTranslation.Value))
                indentWriter.WriteLine($"/// <remarks>{englishTranslation.Value}</remarks>");

            indentWriter.WriteLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
            indentWriter.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCode(\"{TOOL_NAME}\", \"{VERSION}\")]");
            indentWriter.WriteLine($"public static global::{typeof(LString).FullName} {set.Key} {{ get; }} = new global::{typeof(LString).FullName}");
            indentWriter.WriteLine("{");
            indentWriter.Indent++;

            {
                indentWriter.WriteLine($"{nameof(LString.Namespace)} = \"{translations.Namespace}\",");
                indentWriter.WriteLine($"{nameof(LString.Key)} = \"{set.Key}\",");
            }

            indentWriter.Indent--;
            indentWriter.WriteLine("};");
        }

        indentWriter.Indent--;
        indentWriter.WriteLine("}");

        return baseTextWriter.ToString();
    }
}